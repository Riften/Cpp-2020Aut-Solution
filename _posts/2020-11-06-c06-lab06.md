---
layout: post
filename: 2020-11-06-c06-lab06
title: C06 Lab06
date: 2020-11-06 00:00:00 +0800
categories: post
tags:
  - CS171
  - Lab
mathjax: false
---

## 第1关：提取整数（改错题）

```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    int i, j, n;
    char str[80];

    i = 0;
    while ((str[i] = cin.get()) != '\n')
        i++;
    str[i] = '\0';

    n = 0;
    for (j = 0; j < i; j++)
    {
        if (str[j] >= '0' && str[j] <= '9')
            n = n * 10 + (str[j] - '0');
    }
    cout << n % 171 << endl;

    return 0;
}

```

## 第2关：合并数组
这个题目很多同学直接把两个数组合成一个之后排序，这种方法是可以通过这道题目的，但是并不是最好的做法。如果对程序运行的复杂度进行限制，直接排序是效率比较低的。

一种高效的做法是，每次只比较两个数组最小的一个数字，将其中比较小的放进新的数组，然后继续循环访问次小的数，直到输入数组全部被放到了新数组里面。

```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int m, n;
    int a[1000], b[1000];
    int c[2000];

    // 输入
    cin >> m;
    for(int i=0; i<m; i++) {
        cin >> a[i];
    }
    cin >> n;
    for (int i=0; i<n; i++) {
        cin >> b[i];
    }

    // 合并
    int i=0, j = n-1, count=0;
    while(i<m && j>=0) {
        if(a[i] < b[j]) {
            c[count++] = a[i++];
        } else {
            c[count++] = b[j--];
        }
    }

    // 处理剩余未合并的元素
    while(i<m) {
        c[count++] = a[i++];
    }
    while(j>=0) {
        c[count++] = b[j--];
    }

    // 输出
    for(int i=0; i<count; i++) {
        cout << c[i] << " ";
    }
    /******** End *********/
    return 0;
}
```

## 第3关：数组翻转
很多同学在这道题上花了非常大的精力去debug，核心就在于理不清楚索引之间的关系。

实际上做出这道题只需要回答一个问题，在数组关于第k列翻转的时候，哪两列的元素应该互换？为了解决这个问题，可能会有人为此寻找第0列和第k-1列的中间那一列是第几列，可能会有人为此去数应该有几列需要互相交换。

其实不妨换个角度看这个问题，我们其实是知道非常明确边界元素的互换规则的：
- 第`0`列和第`k-1`列互换
- 第`k+1`列和最后一列也就是`n-1`列互换
  
在这个基础上，我们只需要往前思考一步，就可以得到非常简洁的互换规则：
- 第`i`列和第`k-1-i`列互换
- 第`k+1+i`列和`n-1-i`列互换

而完整的互换规则还缺一点，结束条件是什么？有人会判断 “当互换到中间元素的时候结束” ，有人会判断 “当互换一定次数后结束” 。其实在这个情形中，有一个更加简单的结束条件是“当`i >= k-1-i`”的时候结束，也就是当互换的左边的元素不在左边的时候结束。

把上面的过程实现为一个简单的`while`循环就是下面的代码：

```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    int m, n, row, col;
    int a[31][31];
    int tmp;

    // Input
    cin >> m >> n >> row >> col;
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            cin >> a[i][j];
        }
    }

    // Flip rows
    if(row > -1) {
        // 翻转上半边
        int r1=0, r2=row-1;
        while(r1 < r2) {
            for(int j=0; j<n; j++) {
                tmp = a[r1][j];
                a[r1][j] = a[r2][j];
                a[r2][j] = tmp;
            }
            r1++;
            r2--;
        }

        // 翻转下半边
        r1 = row + 1;
        r2 = m - 1;
        while(r1 < r2) {
            for(int j=0; j<n; j++) {
                tmp = a[r1][j];
                a[r1][j] = a[r2][j];
                a[r2][j] = tmp;
            }
            r1++;
            r2--;
        }
    }

    // Flip cols
    if(col > -1) {
        // 翻转左半边
        int c1=0, c2=col-1;
        while(c1 < c2) {
            for(int j=0; j<m; j++) {
                tmp = a[j][c1];
                a[j][c1] = a[j][c2];
                a[j][c2] = tmp;
            }
            c1++;
            c2--;
        }

        // 翻转右半边
        c1 = col + 1;
        c2 = n - 1;
        while(c1 < c2) {
            for(int j=0; j<m; j++) {
                tmp = a[j][c1];
                a[j][c1] = a[j][c2];
                a[j][c2] = tmp;
            }
            c1++;
            c2--;
        }
    }

    // Output
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            cout << a[i][j];
            if(j!=n-1) cout << ' ';
        }
        cout << endl;
    }

    return 0;
}
```

## 第4关：完全数

```cpp
bool isPerfect(int n) {
    int t = 0;
    for(int i=1; i<=n/2; i++) {
        if(n%i==0) {
            t+=i;
        }
    }
    return t==n;
}
```

## 第5关：哈夫曼编码
题目详解见第一次题目讲解讲义。

```cpp
#include <iostream>
using namespace std;

int main() {
    char input[1000];
    int p[128] = {0};
    int n; // 用于遍历字符串的辅助变量

    // 输入
    cin.getline(input, 999);

    // 1. 统计字符频率
    n = 0;
    while(input[n] != '\0') {
        p[input[n++]] += 1;
    }

    // 2. 按照字符频率排序
    char ch[128] = {0};
    for(int i=0; i<128; i++) {
        ch[i] = i;
    }
    char tmp;
    bool flag;
    for(int i=1; i<128; i++){
        flag = false;
        for(int j=0; j<128-i; j++) {
           if(p[ch[j]] < p[ch[j+1]]) {
               tmp = ch[j];
               ch[j] = ch[j+1];
               ch[j+1] = tmp;
               flag = true;
           }
       }
       if(!flag) {
           break;
       }
    }

    // 2. 计算编码
    char huff[128][128]; //huff[i] 是一个01组成的字符串，为字符i的编码结果
    for(int i=0; i<128; i++) {
        tmp = ch[i];
        if (p[tmp] > 0) {
            for (int j=0; j<i; j++) {
                // i-1个1
                huff[tmp][j]='1';
            }
            if(p[ch[i+1]] > 0) {
                // 最后一位是0
                huff[tmp][i] = '0';
                huff[tmp][i+1] = '\0';
            } else {
                // 频率最低的结尾没有额外的0
                huff[tmp][i] = '\0';
            }
        } else {
            break;
        }
    }

    // 4.输出
    n=0;
    while(input[n] != '\0') {
        cout << huff[input[n++]];
    }
    return 0;
}
```