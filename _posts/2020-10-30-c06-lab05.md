---
layout: post
filename: 2020-10-30-c06-lab05
title: C06 Lab05
date: 2020-10-30 00:00:00 +0800
categories: post
tags:
  - CS171
  - Lab
mathjax: false
---

### 第1关：三角形（改错题）
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

int main()
{
    double a, b, c, s, area;

    cin >> a >> b >> c;

    if (a + b > c && a + c > b && b + c > a)
    {
        s = (a + b + c) / 2;
        area = sqrt(s * (s - a) * (s - b) * (s - c));
        cout << setprecision(2) << fixed << area << endl;
    }
    else
        cout << "Error" << endl;

    return 0;
}
```

### 第2关：计算 e（改错题）
```cpp
#include <iostream>
#include <iomanip>

using namespace std;

const double EPS = 1E-6; // 精度

int main()
{
    int i, n, item;
    double e;

    e = 1;
    n = 1;
    item = 1;

    do {
        item *= n;
        e += 1. / item;
        n++;
    } while (1. / item >= EPS);

    cout << fixed << setprecision(6) << e << endl;

    return 0;
}
```

### 第3关：数字转换
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    char s[100];
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    int m[99];
    m['I'] = 1;
    m['V'] = 5;
    m['X'] = 10;
    m['L'] = 50;
    m['C'] = 100;
    m['D'] = 500;
    m['M'] = 1000;
    int sum = 0;                
    for(int i = 0; i < n; i++)
    {
        if (i < n - 1 && m[s[i]] < m[s[i+1]]) {
            sum -= m[s[i]];
        } else {
            sum += m[s[i]];
        }
    }   
    cout << sum;
    return 0;
    /******** End *********/
    return 0;
}
```

### 第4关：换零钱

方法一：先将零钱全部分为 5 元和 1 元，然后减少 5 元的个数，增加 1 元的个数，计算将 1 元转换为 2 元的种类数。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    n -= 8;
    int k = n / 5;
    int x = n % 5;
    int sum = 0;
    for (int i = 0; i <= k; i++) {
        sum += 1 + (x + 5 * i) / 2;
    }
    cout << sum;
    /******** End *********/
    return 0;
}
```

上述求和过程可改写为：
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    n -= 8;
    int k = n / 5;
    int x = n % 5;
    cout << ((k + 1) * x + 5 * k * (k + 1) / 2 - (k + 1) / 2 - (k % 2 == 0 ? x % 2 : 0)) / 2 + k + 1;
    /******** End *********/
    return 0;
}
```

方法二：学生代码，最直接的方法，计算每种纸币最多的数目，遍历求和即可。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n,a,b,c,x=0;
    cin>>n;
    for (a=1;a<=n;a++){
        for (b=1;b<=n/2;b++){
            for (c=1;c<=n/5;c++){
                if(n==a+2*b+5*c)x++;
            }
        }
    }
    cout<<x;
    /******** End *********/
    return 0;
}
```

方法三：学生代码，使用了动态规划，每一个循环考虑某一种纸币，`a[n]` 表示已考虑的纸币中可能的分配方法数。

比方说，对于一个 `k` 元纸币，`a[n + k] = a[n + k] + a[n]`，求和的第一项表示不使用当前 `k` 元纸币的可能分配（旧状态），第二项表示使用当前 `k` 元纸币的可能分配，该项的值就是 `a[n]`（因为已经使用了该 `k` 元纸币，也就是分配剩下的 `n` 元）。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int a[1000]={0};
    a[0]=1;
    for(int i=0;i<=100;i++)a[i+1]+=a[i];
    for(int i=0;i<=100;i++)a[i+2]+=a[i];
    for(int i=0;i<=100;i++)a[i+5]+=a[i];
    int n;
    cin>>n;
    cout<<a[n-8];
    /******** End *********/
    return 0;
}
```

动态规划一般是高效的，方法三的复杂度是线性的，方法一未改写时也是线性的，改写后是常数复杂度（最小的复杂度），方法二是三次的；动态规划的另一个优点是计算出了所有状态下的解，方法三中数组 `a` 可以直接得到任意 `n` 的分配方法数。

### 第5关：第 k 大的数

方法一：构造一个数组，用数组索引记录元素，元素便自动有序了。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int k, n, m = 0, temp;
    bool mask[10001] = {0};
    cin >> k >> n;
    for (int i = 0; i < n; i++) {
        cin >> temp;
        mask[temp] = 1;
    }
    for (int i = 10000; i >= 0; i--) {
        if (mask[i]) {
            if (i > m) {
                m = i;
            }
            k--;
            if (k == 0) {
                cout << i;
                break;
            }
        }
    }
    if (k > 0) {
        cout << m;
    }
    /******** End *********/
    return 0;
}
```

方法二：排序后查找。