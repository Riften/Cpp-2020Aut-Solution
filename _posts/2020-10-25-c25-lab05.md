---
layout: post
filename: 2020-10-25-c25-lab05
title: C25 Lab05
date: 2020-10-25 00:00:00 +0800
categories: post
tags:
  - CS171
  - Lab
mathjax: false
---

### 第1关：三角形（改错题）
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

int main()
{
    double a, b, c, s, area;

    cin >> a >> b >> c;

    if (a + b > c && a + c > b && b + c > a)
    {
        s = (a + b + c) / 2;
        area = sqrt(s * (s - a) * (s - b) * (s - c));
        cout << setprecision(2) << fixed << area << endl;
    }
    else
        cout << "Error" << endl;

    return 0;
}
```

### 第2关：计算 e（改错题）
```cpp
#include <iostream>
#include <iomanip>

using namespace std;

const double EPS = 1E-6; // 精度

int main()
{
    int i, n, item;
    double e;

    e = 1;
    n = 1;
    item = 1;

    do {
        item *= n;
        e += 1. / item;
        n++;
    } while (1. / item >= EPS);

    cout << fixed << setprecision(6) << e << endl;

    return 0;
}
```

### 第3关：数字转换
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    char s[100];
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    int m[99];
    m['I'] = 1;
    m['V'] = 5;
    m['X'] = 10;
    m['L'] = 50;
    m['C'] = 100;
    m['D'] = 500;
    m['M'] = 1000;
    int sum = 0;                
    for(int i = 0; i < n; i++)
    {
        if (i < n - 1 && m[s[i]] < m[s[i+1]]) {
            sum -= m[s[i]];
        } else {
            sum += m[s[i]];
        }
    }   
    cout << sum;
    return 0;
    /******** End *********/
    return 0;
}
```

### 第4关：换零钱

方法一：先将零钱全部分为 5 元和 1 元，然后减少 5 元的个数，增加 1 元的个数，计算将 1 元转换为 2 元的种类数。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    n -= 8;
    int k = n / 5;
    int x = n % 5;
    int sum = 0;
    for (int i = 0; i <= k; i++) {
        sum += 1 + (x + 5 * i) / 2;
    }
    cout << sum;
    /******** End *********/
    return 0;
}
```

上述求和过程可改写为：
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n;
    cin >> n;
    n -= 8;
    int k = n / 5;
    int x = n % 5;
    cout << ((k + 1) * x + 5 * k * (k + 1) / 2 - (k + 1) / 2 - (k % 2 == 0 ? x % 2 : 0)) / 2 + k + 1;
    /******** End *********/
    return 0;
}
```

方法二：黄文鑫同学的代码，最直接的方法，计算每种纸币最多的数目，遍历求和即可。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int n,a,b,c,x=0;
    cin>>n;
    for (a=1;a<=n;a++){
        for (b=1;b<=n/2;b++){
            for (c=1;c<=n/5;c++){
                if(n==a+2*b+5*c)x++;
            }
        }
    }
    cout<<x;
    /******** End *********/
    return 0;
}
```

方法三：何啓成同学的代码，使用了动态规划，每一个循环考虑某一种纸币，`a[n]` 表示已考虑的纸币中可能的分配方法数。

比方说，对于一个 `k` 元纸币，`a[n + k] = a[n + k] + a[n]`，求和的第一项表示不使用当前 `k` 元纸币的可能分配（旧状态），第二项表示使用当前 `k` 元纸币的可能分配，该项的值就是 `a[n]`（因为已经使用了该 `k` 元纸币，也就是分配剩下的 `n` 元）。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int a[1000]={0};
    a[0]=1;
    for(int i=0;i<=100;i++)a[i+1]+=a[i];
    for(int i=0;i<=100;i++)a[i+2]+=a[i];
    for(int i=0;i<=100;i++)a[i+5]+=a[i];
    int n;
    cin>>n;
    cout<<a[n-8];
    /******** End *********/
    return 0;
}
```

动态规划一般是高效的，方法三的复杂度是线性的，方法一未改写时也是线性的，改写后是常数复杂度（最小的复杂度），方法二是三次的；动态规划的另一个优点是计算出了所有状态下的解，方法三中数组 `a` 可以直接得到任意 `n` 的分配方法数。

### 第5关：合并数组

方法一：判断数组元素顺序后直接归并。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int m, n;
    int arr1[1001], arr2[1001], arr3[2001];
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> arr1[i];
    }
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> arr2[i];
    }
    bool rev1 = arr1[0] > arr1[m - 1];
    bool rev2 = arr2[0] > arr2[n - 1];
    int i = 0, j, k = 0, offset;
    if (rev1 == rev2) {
        j = 0;
        offset = 1;
    } else {
        j = n - 1;
        offset = -1;
    }
    while (i < m && j >= 0 && j < n) {
        if (arr1[i] > arr2[j] == rev1) {
            arr3[k++] = arr1[i++];
        } else {
            arr3[k++] = arr2[j];
            j += offset;
        }
    }
    while (i < m) {
        arr3[k++] = arr1[i++];
    }
    while (j >= 0 && j < n) {
        arr3[k++] = arr2[j];
        j += offset;
    }
    for (int i = 0; i < k; i++) {
        cout << arr3[i] << " ";
    }
    /******** End *********/
    return 0;
}
```

方法二：吴祺欢同学的代码，合并数组后排序。（看了好几个同学的代码，发现一个普遍问题，判断数组元素顺序时使用了相邻两项判断，这是有问题的，包括吴同学的代码，因为数组存在相同元素，可以像方法一一样使用首尾两项判断，因为题目说明了数组元素不会全部相同）
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    int n,m,a[10000],b[10000],h,s;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
     cin>>m;
     for(int j=1;j<=m;j++)
     {
         cin>>b[j];
     }
     for(int i=n+1;i<=m+n;i++)
     {
         for(int j= i-n;j<=m;j++)
         {
             a[i]=b[j];
             break;
         }
     }
     if(a[1]>=a[2])
     {
         for(int k=1;k<=m+n;k++)
         {
             for(int i=k;i<=m+n;i++)
             {
                 if(a[i]>=a[k])
                 {
                 s=a[k];
                 a[k]=a[i];
                 a[i]=s;
                 }
             }
         }
     }
     if(a[1]<=a[2])
     {
         for(int k=1;k<=m+n;k++)
         {
             for(int i=k;i<=m+n;i++)
             {
                 if(a[i]<=a[k])
                 {
                     h=a[k];
                     a[k]=a[i];
                     a[i]=h;
                 }
             }
         }
     }
     for(int i=1;i<=m+n;i++)
     cout<<a[i]<<" ";
    return 0;
}
```

### 第6关：第 k 大的数

方法一：构造一个数组，用数组索引记录元素，元素便自动有序了。
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    /*** Your code here ***/
    int k, n, m = 0, temp;
    bool mask[10001] = {0};
    cin >> k >> n;
    for (int i = 0; i < n; i++) {
        cin >> temp;
        mask[temp] = 1;
    }
    for (int i = 10000; i >= 0; i--) {
        if (mask[i]) {
            if (i > m) {
                m = i;
            }
            k--;
            if (k == 0) {
                cout << i;
                break;
            }
        }
    }
    if (k > 0) {
        cout << m;
    }
    /******** End *********/
    return 0;
}
```

方法二：排序后查找。